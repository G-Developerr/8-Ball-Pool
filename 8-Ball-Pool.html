<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Ball Pool Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #2b2b2b;
            font-family: Arial, sans-serif;
            overflow: hidden;
            flex-direction: column;
        }
        .game-container {
            position: relative;
            width: 900px;
            height: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .table-container {
            position: relative;
        }
        canvas {
            border: 10px solid #5D4037;
            border-radius: 5px;
            background: #0a4d25;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        .score {
            position: absolute;
            top: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #player1Score {
            left: 20px;
        }
        #player2Score {
            right: 20px;
        }
        .player-balls {
            position: absolute;
            top: 50px;
            color: white;
            font-size: 16px;
            text-shadow: 1px 1px 1px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            max-width: 200px;
        }
        #player1Balls {
            left: 20px;
        }
        #player2Balls {
            right: 20px;
        }
        .turn-message {
            width: 100%;
            text-align: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .game-message {
            width: 100%;
            text-align: center;
            color: #ffcc00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .instructions {
            width: 100%;
            text-align: center;
            color: #ccc;
            font-size: 16px;
            text-shadow: 1px 1px 1px black;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 0;
            margin-top: 10px;
        }
        .reset-btn {
            padding: 8px 16px;
            background: #5D4037;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        .reset-btn:hover {
            background: #8D6E63;
        }
        .ball-message {
            position: absolute;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        .foul-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="turnMessage" class="turn-message">Player 1's turn</div>
        <div id="gameMessage" class="game-message">BREAK! Hit the balls hard!</div>
        
        <div class="table-container">
            <div id="player1Score" class="score">Player 1: 0</div>
            <div id="player2Score" class="score">Player 2: 0</div>
            <div id="player1Balls" class="player-balls">Player 1 Balls: </div>
            <div id="player2Balls" class="player-balls">Player 2 Balls: </div>
            <canvas id="poolTable" width="900" height="500"></canvas>
        </div>
        
        <div id="instructions" class="instructions">Drag mouse from cue ball to shoot</div>
        <button id="resetBtn" class="reset-btn">Reset Game</button>
    </div>

    <script>
        let globalFirstHitBall = null;
       const canvas = document.getElementById("poolTable");
const ctx = canvas.getContext("2d");
const gameMessage = document.getElementById("gameMessage");
const instructions = document.getElementById("instructions");
const resetBtn = document.getElementById("resetBtn");
const turnMessage = document.getElementById("turnMessage");

// Sound effects
const sounds = {
    collision: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-jump-coin-216.mp3'),
    pocket: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3'),
    win: new Audio('https://assets.mixkit.co/sfx/preview/mixkit-game-level-completed-2059.mp3')
};

function playSound(name) {
    try {
        sounds[name].currentTime = 0;
        sounds[name].play();
    } catch (e) {
        console.log("Sound error:", e);
    }
}

class Ball {
    constructor(x, y, radius, color, number, isStriped) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.number = number;
        this.isStriped = isStriped;
        this.dx = 0;
        this.dy = 0;
        this.friction = 0.985;
        this.isPocketed = false;
        this.lastCollision = 0;
        this.pocketedBy = null;
        this.pocketTime = 0;
        this.wasHit = false;
    }

    draw() {
        if (this.isPocketed) return;

        // Draw ball shadow
        ctx.beginPath();
        ctx.arc(this.x + 2, this.y + 2, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fill();

        // Draw ball
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();

        // Draw stripe if needed
        if (this.isStriped) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 0.85, 0, Math.PI * 2);
            ctx.strokeStyle = "white";
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        // Draw number
        ctx.fillStyle = this.number === 8 ? "white" : "black";
        ctx.font = "bold " + (this.radius * 0.8) + "px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.number, this.x, this.y);
    }

    update(balls, pockets) {
        if (this.isPocketed) return;

        // Reset hit flag at start of each shot
        if (allBallsStopped()) {
            this.wasHit = false;
        }

        this.x += this.dx;
        this.y += this.dy;

        this.dx *= this.friction;
        this.dy *= this.friction;

        if (Math.abs(this.dx) < 0.05) this.dx = 0;
        if (Math.abs(this.dy) < 0.05) this.dy = 0;

        // Check for pocket collisions
        for (let pocket of pockets) {
            const dx = this.x - pocket.x;
            const dy = this.y - pocket.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < pocket.radius) {
                this.isPocketed = true;
                this.pocketedBy = currentPlayer;
                this.pocketTime = Date.now();
                handlePocketedBall(this);
                playSound('pocket');
                break;
            }
        }

        // Wall collisions
        if (!this.isPocketed) {
            if (this.x - this.radius < 0) {
                this.x = this.radius;
                this.dx = -this.dx * 0.9;
                playSound('collision');
            }
            if (this.x + this.radius > canvas.width) {
                this.x = canvas.width - this.radius;
                this.dx = -this.dx * 0.9;
                playSound('collision');
            }
            if (this.y - this.radius < 0) {
                this.y = this.radius;
                this.dy = -this.dy * 0.9;
                playSound('collision');
            }
            if (this.y + this.radius > canvas.height) {
                this.y = canvas.height - this.radius;
                this.dy = -this.dy * 0.9;
                playSound('collision');
            }
        }

        // Ball collisions
        const nearbyBalls = getNearbyBalls(this, balls);
        for (let otherBall of nearbyBalls) {
            if (this === otherBall || otherBall.isPocketed) continue;
            
            const dx = this.x - otherBall.x;
            const dy = this.y - otherBall.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = this.radius + otherBall.radius;

            if (distance < minDistance && Date.now() - this.lastCollision > 50) {
                if (this.number === 0 && globalFirstHitBall === null) {
    globalFirstHitBall = otherBall;
             }
             if (otherBall.number === 0 && globalFirstHitBall === null) {
             globalFirstHitBall = this;
            }

                const angle = Math.atan2(dy, dx);
                const sin = Math.sin(angle);
                const cos = Math.cos(angle);
                
                const vx1 = this.dx * cos + this.dy * sin;
                const vy1 = this.dy * cos - this.dx * sin;
                const vx2 = otherBall.dx * cos + otherBall.dy * sin;
                const vy2 = otherBall.dy * cos - otherBall.dx * sin;
                
                const finalVx1 = vx2;
                const finalVx2 = vx1;
                
                this.dx = finalVx1 * cos - vy1 * sin;
                this.dy = vy1 * cos + finalVx1 * sin;
                otherBall.dx = finalVx2 * cos - vy2 * sin;
                otherBall.dy = vy2 * cos + finalVx2 * sin;
                
                const overlap = (minDistance - distance) / 2;
                this.x += overlap * (dx / distance);
                this.y += overlap * (dy / distance);
                otherBall.x -= overlap * (dx / distance);
                otherBall.y -= overlap * (dy / distance);
                
                this.lastCollision = Date.now();
                otherBall.lastCollision = Date.now();
                this.wasHit = true;
                otherBall.wasHit = true;
                playSound('collision');
            }
        }

        this.draw();
    }

    shoot(power, angle) {
        this.dx = power * Math.cos(angle);
        this.dy = power * Math.sin(angle);
        this.wasHit = true;
    }
}

class Cue {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.angle = 0;
        this.power = 0;
        this.isVisible = false;
        this.pullDistance = 0;
        this.maxPower = 30;
    }

   draw() {
    if (!this.isVisible) return;

    const cueBall = balls[0];
    const endX = cueBall.x + Math.cos(this.angle) * 600; // ÎœÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿ Î¼Î®ÎºÎ¿Ï‚
    const endY = cueBall.y + Math.sin(this.angle) * 600;

    // 1. Î“ÏÎ±Î¼Î¼Î® ÎºÎ±Î¸Î¿Î´Î®Î³Î·ÏƒÎ·Ï‚ (guide line) Î¼Îµ Î´Î¹Î±ÎºÎµÎºÎ¿Î¼Î¼Î­Î½Î· Î³ÏÎ±Î¼Î¼Î®
    ctx.beginPath();
    ctx.moveTo(cueBall.x, cueBall.y);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 4]);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.save();
    ctx.translate(cueBall.x, cueBall.y);
    ctx.rotate(this.angle);

    // 2. Î£ÎšÎ™Î‘ Î£Î¤Î•ÎšÎ‘Î£ (Ï€Î¹Î¿ Î¼Î±Î»Î±ÎºÎ® ÎºÎ±Î¹ Î¼ÎµÎ³Î±Î»ÏÏ„ÎµÏÎ·)
    ctx.beginPath();
    ctx.moveTo(-250 - this.pullDistance, 8);
    ctx.lineTo(-30 - this.pullDistance, 8);
    ctx.strokeStyle = "rgba(0, 0, 0, 0.25)";
    ctx.lineWidth = 14;
    ctx.lineCap = "round";
    ctx.stroke();

    // 3. ÎšÎ¥Î¡Î™ÎŸ Î£Î©ÎœÎ‘ Î£Î¤Î•ÎšÎ‘Î£ (Î¼Îµ Ï€Î¹Î¿ Î­Î½Ï„Î¿Î½Î± gradients ÎºÎ±Î¹ Î±Î½Ï„Î±ÏÎ³ÎµÎ¹ÎµÏ‚)
    const cueLength = 220; // ÎœÎµÎ³Î±Î»ÏÏ„ÎµÏÎ¿ Î¼Î®ÎºÎ¿Ï‚
    const tipStart = -30 - this.pullDistance;
    const buttEnd = -250 - this.pullDistance;

    // Î’Î±ÏƒÎ¹ÎºÏŒ gradient (Î¾ÏÎ»Î¿ + Î¼ÎµÏ„Î±Î»Î»Î¹ÎºÎ­Ï‚ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚)
    const woodGradient = ctx.createLinearGradient(tipStart, 0, buttEnd, 0);
    woodGradient.addColorStop(0, "#6D4C41");   // Î£ÎºÎ¿ÏÏÎ¿ ÎºÎ±Ï†Î­ (Î¬ÎºÏÎ·)
    woodGradient.addColorStop(0.4, "#8D6E63"); // ÎœÎ­Ï„ÏÎ¹Î¿ ÎºÎ±Ï†Î­
    woodGradient.addColorStop(0.7, "#D7CCC8"); // Î‘Î½Î¿Î¹Ï‡Ï„ÏŒ ÎºÎ±Ï†Î­ (Î±Î½Ï„Î±ÏÎ³ÎµÎ¹Î±)
    woodGradient.addColorStop(1, "#4E342E");   // Î Î¿Î»Ï ÏƒÎºÎ¿ÏÏÎ¿ (Î²Î¬ÏƒÎ·)

    // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· ÎºÏ…ÏÎ¯Ï‰Ï‚ ÏƒÏŽÎ¼Î±Ï„Î¿Ï‚ (Ï€Î¹Î¿ Ï€Î±Ï‡Ï ÎºÎ±Î¹ Î¼Îµ Î»ÎµÏ€Ï„Î¿Î¼Î­ÏÎµÎ¹ÎµÏ‚)
    ctx.beginPath();
    ctx.moveTo(tipStart, -6);
    ctx.lineTo(buttEnd, -6);
    ctx.lineTo(buttEnd, 6);
    ctx.lineTo(tipStart, 6);
    ctx.closePath();
    ctx.fillStyle = woodGradient;
    ctx.fill();

    // 4. ÎœÎ¥Î¤Î— Î£Î¤Î•ÎšÎ‘Î£ (Ï€Î¹Î¿ Î»ÎµÏ…ÎºÎ® ÎºÎ±Î¹ Î³Ï…Î±Î»Î¹ÏƒÏ„ÎµÏÎ®)
    const tipGradient = ctx.createRadialGradient(
        tipStart + 10, 0, 0, 
        tipStart + 10, 0, 8
    );
    tipGradient.addColorStop(0, "#FFFFFF");
    tipGradient.addColorStop(0.7, "#E0E0E0");
    tipGradient.addColorStop(1, "#BCAAA4");

    ctx.beginPath();
    ctx.arc(tipStart + 10, 0, 6, 0, Math.PI * 2);
    ctx.fillStyle = tipGradient;
    ctx.fill();

    // Î‘Î½Ï„Î±ÏÎ³ÎµÎ¹Î± ÏƒÏ„Î·Î½ Î¼ÏÏ„Î· (highlight)
    ctx.beginPath();
    ctx.arc(tipStart + 12, -2, 2, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
    ctx.fill();

    // 5. Î”Î™Î‘ÎšÎŸÎ£ÎœÎ—Î¤Î™ÎšÎ•Î£ Î›Î©Î¡Î™Î”Î•Î£ (ÏŒÏ€Ï‰Ï‚ Ï€ÏÎ±Î³Î¼Î±Ï„Î¹ÎºÎ­Ï‚ ÏƒÏ„Î­ÎºÎµÏ‚)
    const ringColors = ["#3E2723", "#5D4037", "#8D6E63"];
    const ringPositions = [-50, -100, -150, -200];
    
    ringPositions.forEach((pos, i) => {
        if (pos < buttEnd) return;

        ctx.fillStyle = ringColors[i % ringColors.length];
        ctx.fillRect(pos - this.pullDistance, -7, 4, 14); // Î Î±Ï‡ÏÏ„ÎµÏÎµÏ‚ Î»Ï‰ÏÎ¯Î´ÎµÏ‚
    });

    // 6. Î•Î¦Î• Î¦Î©Î¤Î™Î£ÎœÎŸÎ¥ (Ï€Î¹Î¿ Î´Ï…Î½Î±Î¼Î¹ÎºÏŒ)
    ctx.beginPath();
    ctx.moveTo(tipStart, -4);
    ctx.lineTo(buttEnd, -4);
    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.restore();
}


    update(x, y, angle, pullDistance) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.pullDistance = Math.min(pullDistance, 50);
        this.power = (this.pullDistance / 50) * this.maxPower;
        this.isVisible = true;
    }

    hide() {
        this.isVisible = false;
    }
}

// Game elements
const pockets = [
    { x: 0, y: 0, radius: 30 },
    { x: canvas.width / 2, y: 0, radius: 30 },
    { x: canvas.width, y: 0, radius: 30 },
    { x: 0, y: canvas.height, radius: 30 },
    { x: canvas.width / 2, y: canvas.height, radius: 30 },
    { x: canvas.width, y: canvas.height, radius: 30 }
];

let balls = [];
let cue = new Cue();
let isShooting = false;
let startX, startY;
let foulMessage = "";
let isPlacingCueBall = false;
let currentPlayer = 1;
let player1Score = 0;
let player2Score = 0;
let player1Balls = [];
let player2Balls = [];
let isBreakPhase = true;
let player1Type = null;
let player2Type = null;
let gameOver = false;
let winner = null;
let foulTimer = null;
const gridSize = 50;
let grid = {};
let ballMessages = [];

function initGame() {
    balls = [
        new Ball(300, 250, 12, "white", 0, false), // Cue ball
        new Ball(600, 250, 12, "yellow", 1, false),
        new Ball(620, 230, 12, "blue", 2, false),
        new Ball(620, 270, 12, "red", 3, false),
        new Ball(640, 210, 12, "purple", 4, false),
        new Ball(640, 250, 12, "orange", 5, false),
        new Ball(640, 290, 12, "green", 6, false),
        new Ball(660, 190, 12, "maroon", 7, false),
        new Ball(660, 230, 12, "black", 8, false),
        new Ball(660, 270, 12, "yellow", 9, true),
        new Ball(660, 310, 12, "blue", 10, true),
        new Ball(680, 210, 12, "red", 11, true),
        new Ball(680, 250, 12, "purple", 12, true),
        new Ball(680, 290, 12, "orange", 13, true),
        new Ball(700, 230, 12, "green", 14, true),
        new Ball(700, 270, 12, "maroon", 15, true)
    ];
    
    cue = new Cue();
    isShooting = false;
    foulMessage = "";
    isPlacingCueBall = false;
    currentPlayer = 1;
    player1Score = 0;
    player2Score = 0;
    player1Balls = [];
    player2Balls = [];
    isBreakPhase = true;
    player1Type = null;
    player2Type = null;
    gameOver = false;
    winner = null;
    grid = {};
    ballMessages = [];
    
    updateTurnMessage();
    gameMessage.textContent = "BREAK! Hit the balls hard!";
    instructions.textContent = "Drag mouse from cue ball to shoot";
    updateScores();
    updatePlayerBallsDisplay();
}

function updateGrid() {
    grid = {};
    for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        if (ball.isPocketed) continue;
        
        const gridX = Math.floor(ball.x / gridSize);
        const gridY = Math.floor(ball.y / gridSize);
        const key = `${gridX},${gridY}`;
        
        if (!grid[key]) {
            grid[key] = [];
        }
        grid[key].push(ball);
    }
}

function getNearbyBalls(ball, balls) {
    const gridX = Math.floor(ball.x / gridSize);
    const gridY = Math.floor(ball.y / gridSize);
    const nearbyBalls = [];
    
    for (let x = gridX - 1; x <= gridX + 1; x++) {
        for (let y = gridY - 1; y <= gridY + 1; y++) {
            const key = `${x},${y}`;
            if (grid[key]) {
                nearbyBalls.push(...grid[key]);
            }
        }
    }
    
    return nearbyBalls.filter(b => b !== ball && !b.isPocketed);
}

function isNearCueBall(mouseX, mouseY) {
    const cueBall = balls[0];
    const dx = mouseX - cueBall.x;
    const dy = mouseY - cueBall.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance < 50 && !isPlacingCueBall && !gameOver && allBallsStopped();
}

function allBallsStopped() {
    return balls.every(ball => {
        if (ball.isPocketed && ball.number !== 0) return true;
        if (ball.number === 0) return Math.abs(ball.dx) < 0.05 && Math.abs(ball.dy) < 0.05;
        return Math.abs(ball.dx) < 0.05 && Math.abs(ball.dy) < 0.05;
    });
}

function checkFoul() {
    const cueBall = balls[0];
    let isFoul = false;

    // Break phase: No fouls except cue ball pocketed
    if (isBreakPhase) {
        if (cueBall.isPocketed) {
            foulMessage = "Foul! Cue ball pocketed.";
            isFoul = true;
        }
        return isFoul;
    }

    // Regular game: Check standard fouls
    if (cueBall.isPocketed) {
        foulMessage = "Foul! Cue ball pocketed.";
        isFoul = true;
    }

    const firstHitBall = globalFirstHitBall;

    if (!firstHitBall) {
        foulMessage = "Foul! No ball was hit.";
        isFoul = true;
    }

    // Check if wrong ball was hit first (only if types are assigned)
    if (!isFoul && player1Type && player2Type && firstHitBall) {
        const playerType = currentPlayer === 1 ? player1Type : player2Type;
        const isPlayerBall = (playerType === 'solid' && !firstHitBall.isStriped) ||
                             (playerType === 'striped' && firstHitBall.isStriped);

        const currentPlayerBalls = currentPlayer === 1 ? player1Balls : player2Balls;

        // Î‘Î½ Ï‡Ï„Ï…Ï€Î®Î¸Î·ÎºÎµ Ï€ÏÏŽÏ„Î± Î· 8-ball Ï‡Ï‰ÏÎ¯Ï‚ Î½Î± Î­Ï‡Î¿Ï…Î½ Î²Î¬Î»ÎµÎ¹ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î´Î¹ÎºÎ­Ï‚ Ï„Î¿Ï…Ï‚
        if (firstHitBall.number === 8 && currentPlayerBalls.length < 7) {
            foulMessage = "Foul! Hit the 8-ball too early.";
            isFoul = true;
        } else if (!isPlayerBall && firstHitBall.number !== 8) {
            foulMessage = `Foul! Wrong ball hit (${firstHitBall.number}).`;
            isFoul = true;
        }
    }

    if (isFoul) {
        clearTimeout(foulTimer);
        foulTimer = setTimeout(() => { foulMessage = ""; }, 3000);
        isPlacingCueBall = true;
    }

    return isFoul;
}


function handlePocketedBall(ball) {
    if (ball.number === 0) return;

    // Î‘Î½ Î¼Ï€Î®ÎºÎµ Î· Î¼Î±ÏÏÎ· Î¼Ï€Î¬Î»Î±
    if (ball.number === 8) {
        const currentPlayerBalls = currentPlayer === 1 ? player1Balls : player2Balls;
        const allBallsPocketed = currentPlayerBalls.length === 7;

        gameOver = true;

        if (allBallsPocketed) {
            winner = currentPlayer;
            gameMessage.textContent = `ðŸŽ‰ Player ${winner} wins! ðŸŽ±`;
        } else {
            winner = currentPlayer === 1 ? 2 : 1;
            gameMessage.textContent = `âŒ Player ${winner} wins! (8-ball was pocketed too early)`;
        }

        instructions.textContent = "Restarting game in 3 seconds...";
        playSound('win');

        setTimeout(() => {
            initGame(); // ÎžÎµÎºÎ¹Î½Î¬ Î½Î­Î¿ Ï€Î±Î¹Ï‡Î½Î¯Î´Î¹
        }, 3000);

        return;
    }

    // ÎšÎ±Ï„Î±Î³ÏÎ±Ï†Î® Î¼Ï€Î¬Î»Î±Ï‚ Î³Î¹Î± Ï„Î¿Î½ Î³ÏÏÎ¿
    ballsPocketedThisTurn.push(ball.number);

    // Î‘Î½ Î´ÎµÎ½ Î­Ï‡Î¿Ï…Î½ Î¿ÏÎ¹ÏƒÏ„ÎµÎ¯ Î¿Î¹ Ï„ÏÏ€Î¿Î¹ Ï€Î±Î¹ÎºÏ„ÏŽÎ½
    if (player1Type === null && !isBreakPhase) {
        assignPlayerTypes(ball);
    }

    // ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î±Î½ Î¼Ï€Î®ÎºÎµ Î¼Ï€Î¬Î»Î± Î±Î½Ï„Î¹Ï€Î¬Î»Î¿Ï…
    if (player1Type !== null && player2Type !== null) {
        const opponentType = currentPlayer === 1 ? player2Type : player1Type;
        const isOpponentBall = (opponentType === 'solid' && !ball.isStriped) ||
                               (opponentType === 'striped' && ball.isStriped);

        if (isOpponentBall) {
            foulMessage = "Foul! Pocketed opponent's ball.";
            isPlacingCueBall = true;
            instructions.textContent = "Click to place the cue ball";
            return;
        }
    }

    // Î‘Î½ ÎµÎ¯Î½Î±Î¹ Î­Î³ÎºÏ…ÏÎ· Î¼Ï€Î¬Î»Î±, ÎºÎ±Ï„Î±Ï‡ÏŽÏÎ·ÏƒÎ­ Ï„Î·Î½
    if (player1Type === null || player2Type === null || checkBallType(ball)) {
        const playerBalls = currentPlayer === 1 ? player1Balls : player2Balls;
        if (!playerBalls.includes(ball.number)) {
            playerBalls.push(ball.number);
            playerBalls.sort((a, b) => a - b);
            ballMessages.push({ x: ball.x, y: ball.y, player: currentPlayer, time: Date.now() });
        }
    } else {
        // Î‘Î½ Î¼Ï€Î®ÎºÎµ Î»Î¬Î¸Î¿Ï‚ Ï„ÏÏ€Î¿Ï‚ Î¼Ï€Î¬Î»Î±Ï‚
        foulMessage = "Foul! Wrong ball pocketed.";
        isPlacingCueBall = true;
        instructions.textContent = "Click to place the cue ball";
        return;
    }

    updatePlayerBallsDisplay();
    updateScores();
}




function checkBallType(ball) {
    if (ball.number === 8) {
        const playerBalls = ball.pocketedBy === 1 ? player1Balls : player2Balls;
        return playerBalls.length === 7;
    }

    if (player1Type === null || player2Type === null) return true;

    const playerType = ball.pocketedBy === 1 ? player1Type : player2Type;
    return (playerType === 'solid' && !ball.isStriped) || 
           (playerType === 'striped' && ball.isStriped);
}

function updatePlayerBallsDisplay() {
    const player1BallsDisplay = player1Balls.join(", ");
    const player2BallsDisplay = player2Balls.join(", ");

    if (player1Type && player2Type) {
        const player1TypeDisplay = player1Type === 'solid' ? 'Solids' : 'Stripes';
        const player2TypeDisplay = player2Type === 'solid' ? 'Solids' : 'Stripes';
        document.getElementById("player1Balls").textContent = 
            `Player 1 Balls: ${player1BallsDisplay} (${player1TypeDisplay})`;
        document.getElementById("player2Balls").textContent = 
            `Player 2 Balls: ${player2BallsDisplay} (${player2TypeDisplay})`;
    } else {
        document.getElementById("player1Balls").textContent = 
            `Player 1 Balls: ${player1BallsDisplay}`;
        document.getElementById("player2Balls").textContent = 
            `Player 2 Balls: ${player2BallsDisplay}`;
    }
}

function updateTurnMessage() {
    turnMessage.textContent = `Player ${currentPlayer}'s turn`;
    turnMessage.style.color = currentPlayer === 1 ? "#4CAF50" : "#F44336";
}

function updateScores() {
    player1Score = player1Balls.length;
    player2Score = player2Balls.length;
    document.getElementById("player1Score").textContent = `Player 1: ${player1Score}`;
    document.getElementById("player2Score").textContent = `Player 2: ${player2Score}`;
}

function assignPlayerTypes(firstBall) {
    if (player1Type !== null || player2Type !== null) return;

    const firstPlayer = firstBall.pocketedBy;

    if (firstBall.isStriped) {
        if (firstPlayer === 1) {
            player1Type = 'striped';
            player2Type = 'solid';
        } else {
            player2Type = 'striped';
            player1Type = 'solid';
        }
    } else {
        if (firstPlayer === 1) {
            player1Type = 'solid';
            player2Type = 'striped';
        } else {
            player2Type = 'solid';
            player1Type = 'striped';
        }
    }

    player1Balls.sort((a, b) => a - b);
    player2Balls.sort((a, b) => a - b);

    updateTurnMessage();
    updatePlayerBallsDisplay();
    gameMessage.textContent = "";
    isBreakPhase = false;
}

let ballsPocketedThisTurn = [];

function resetAfterShot() {
    const foulCommitted = checkFoul();
    const pocketedThisShot = balls.filter(ball => 
        ball.isPocketed && ball.number !== 0 && ball.pocketedBy === currentPlayer
    );

    if (isBreakPhase) {
        if (pocketedThisShot.length > 0) {
            assignPlayerTypes(pocketedThisShot[0]);
            isBreakPhase = false;
        }
        if (pocketedThisShot.length === 0 || foulCommitted) {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnMessage();
        }
    } else {
        const playerType = currentPlayer === 1 ? player1Type : player2Type;

        const scoredValidBall = pocketedThisShot.some(ball =>
            (playerType === 'solid' && !ball.isStriped) ||
            (playerType === 'striped' && ball.isStriped)
        );

        if (foulCommitted) {
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTurnMessage();
} else if (ballsPocketedThisTurn.length === 0) {
    // No ball entered any pocket
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTurnMessage();
} else if (!scoredValidBall) {
    // Wrong ball entered
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTurnMessage();
}
    }

    updatePlayerBallsDisplay();
    updateScores();

    if (balls[0].isPocketed) {
        isPlacingCueBall = true;
        instructions.textContent = "Click to place the cue ball";
    } else {
        instructions.textContent = "Drag mouse from cue ball to shoot";
    }

    globalFirstHitBall = null;
    ballsPocketedThisTurn = [];

}


function drawPockets() {
    pockets.forEach(pocket => {
        ctx.beginPath();
        ctx.arc(pocket.x + 2, pocket.y + 2, pocket.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fill();
        
        const gradient = ctx.createRadialGradient(
            pocket.x, pocket.y, pocket.radius * 0.3,
            pocket.x, pocket.y, pocket.radius
        );
        gradient.addColorStop(0, "#111");
        gradient.addColorStop(1, "#000");
        
        ctx.beginPath();
        ctx.arc(pocket.x, pocket.y, pocket.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
    });
}

function drawTable() {
    // Î ÏÎ¬ÏƒÎ¹Î½Î¿ Ï„ÏÎ±Ï€Î­Î¶Î¹ Î¼Îµ Î½Ï„ÎµÎ³ÎºÏÎ±Î½Ï„Î­ Î³Î¹Î± Ï€Î¹Î¿ ÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÎ® ÎµÎ¼Ï†Î¬Î½Î¹ÏƒÎ·
    const texture = ctx.createLinearGradient(0, 0, 0, canvas.height);
    texture.addColorStop(0, "#0f5c2b"); // Î±Î½Î¿Î¹Ï‡Ï„ÏŒ Ï€ÏÎ¬ÏƒÎ¹Î½Î¿
    texture.addColorStop(1, "#0a4d25"); // ÏƒÎºÎ¿ÏÏÎ¿ Ï€ÏÎ¬ÏƒÎ¹Î½Î¿
    ctx.fillStyle = texture;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ÎžÏÎ»Î¹Î½Î¿ Ï€ÎµÏÎ¯Î³ÏÎ±Î¼Î¼Î± Ï€Î¹Î¿ â€œÏÎµÎ±Î»Î¹ÏƒÏ„Î¹ÎºÏŒâ€
    ctx.strokeStyle = "#4e342e"; // ÏƒÎºÎ¿ÏÏÎ¿ Î¾ÏÎ»Î¿
    ctx.lineWidth = 20;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);

    // ÎšÎµÎ½Ï„ÏÎ¹ÎºÎ® Î´Î¹Î±ÎºÎµÎºÎ¿Î¼Î¼Î­Î½Î· Î³ÏÎ±Î¼Î¼Î® (ÏƒÎµÎ¼Î¹-Î´Î¹Î¬Ï†Î±Î½Î·)
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, 0);
    ctx.lineTo(canvas.width / 2, canvas.height);
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.setLineDash([]);

    // Î¤ÎµÎ»ÎµÎ¯ÎµÏ‚ ÎºÎ±Î¸Î¿Î´Î®Î³Î·ÏƒÎ·Ï‚ (Ï€Î¹Î¿ Î´Î¹Î±ÎºÏÎ¹Ï„Î¹ÎºÎ­Ï‚)
    const dots = [
        { x: canvas.width / 4, y: canvas.height / 4 },
        { x: canvas.width * 3 / 4, y: canvas.height / 4 },
        { x: canvas.width / 2, y: canvas.height / 2 },
        { x: canvas.width / 4, y: canvas.height * 3 / 4 },
        { x: canvas.width * 3 / 4, y: canvas.height * 3 / 4 }
    ];

    ctx.fillStyle = "rgba(255,255,255,0.5)";
    dots.forEach(dot => {
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
}


function drawBallMessages() {
    const now = Date.now();
    ballMessages = ballMessages.filter(msg => now - msg.time < 3000);
    
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    
    ballMessages.forEach(msg => {
        ctx.fillText(`P${msg.player}`, msg.x, msg.y - 20);
    });
}

// Event listeners
canvas.addEventListener("mousedown", (e) => {
    if (gameOver) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if (isPlacingCueBall) {
        let validPosition = true;
        const cueBallRadius = balls[0].radius;
        
        // Check collision with other balls
        for (const ball of balls) {
            if (ball.isPocketed || ball.number === 0) continue;
            
            const dx = mouseX - ball.x;
            const dy = mouseY - ball.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < cueBallRadius * 3) {
                validPosition = false;
                break;
            }
        }
        
        // Check if within table bounds
        if (mouseX < cueBallRadius * 2 || mouseX > canvas.width - cueBallRadius * 2 || 
            mouseY < cueBallRadius * 2 || mouseY > canvas.height - cueBallRadius * 2) {
            validPosition = false;
        }
        
        if (validPosition) {
            balls[0].x = mouseX;
            balls[0].y = mouseY;
            balls[0].isPocketed = false;
            balls[0].dx = 0;
            balls[0].dy = 0;
            isPlacingCueBall = false;
            foulMessage = "";
            instructions.textContent = "Drag mouse from cue ball to shoot";
        } else {
            foulMessage = "Invalid position! Try again.";
            setTimeout(() => {
                foulMessage = "";
            }, 2000);
        }
    } else if (isNearCueBall(mouseX, mouseY)) {
        isShooting = true;
        startX = mouseX;
        startY = mouseY;
    }
});

document.addEventListener("mousemove", (e) => {
    if (isShooting && !gameOver) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const dx = startX - mouseX;
        const dy = startY - mouseY;
        const angle = Math.atan2(dy, dx);
        const pullDistance = Math.sqrt(dx * dx + dy * dy);
        
        cue.update(startX, startY, angle, pullDistance);
    }
});

document.addEventListener("mouseup", (e) => {
    if (isShooting && !gameOver) {
        const cueBall = balls[0];
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const dx = startX - mouseX;
        const dy = startY - mouseY;
        const power = Math.min(Math.sqrt(dx * dx + dy * dy) / 5, cue.maxPower);
        const angle = Math.atan2(dy, dx);
        
        cueBall.shoot(power, angle);
        isShooting = false;
        cue.hide();

        // Check for stopped balls periodically
        const checkStopped = setInterval(() => {
            if (allBallsStopped()) {
                clearInterval(checkStopped);
                resetAfterShot();
            }
        }, 100);
    }
});

resetBtn.addEventListener("click", initGame);

function animate() {
    //if (gameOver) return;

    drawTable();
    drawPockets();

    if (foulMessage) {
        ctx.fillStyle = "white";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText(foulMessage, canvas.width / 2, canvas.height / 2);
    }

    updateGrid();
    balls.forEach(ball => ball.update(balls, pockets));
    drawBallMessages();

    const cueBall = balls[0];
    if (cueBall.isPocketed && !isPlacingCueBall) {
        foulMessage = "Foul! Place the cue ball.";
        isPlacingCueBall = true;
        instructions.textContent = "Click to place the cue ball";
    }

    updateScores();
    cue.draw();
    
    if (allBallsStopped() && !isShooting) {
        if (isBreakPhase) {
            gameMessage.textContent = "BREAK! Hit the balls hard!";
        } else {
            gameMessage.textContent = "";
        }
    }

    requestAnimationFrame(animate);
}

// Initialize game
initGame();
animate();
    </script>
</body>
</html>